

## Java 基础

### JVM

> JVM 是一种能运行java字节码的虚拟机，以堆栈结构及其来实现，包含自己的指令结构和垃圾回收机制，是一种技术规范，详见[Java虚拟机规范](https://waylau.gitbooks.io/java-virtual-machine-specification/content/)

#### JVM的内存模型

![img](https://raw.githubusercontent.com/HermiteZhang/typoraImage/main/typora/202104/19/181731-551110.webp)

* ==那些区域是线程共享的==：
  * 方法区、java堆是线程共享的
    * 方法区存储类的基本信息，常量池、域信息、方法信息
    * java堆是存储对象实例的内存区，是GC执行的重点位置
  * java栈和方法栈都是存储线程中私有的变量、对象引用以及运行状态的，一般随着线程的生命技术而被回收
* Hotspot、 JRockit（Oracle）、J9（IBM）是jvm的具体实现
* ==方法区和元空间的区别==
  * 方法区是JVM的规范，元空间（**Metaspace**）是java8（Hotspot）对于方法区的实现。
  * java8以前使用的永久代(**PermGen**)来实现方法区，由于动态类加载导致原永久代的实现方式容易造成内存溢出。
  * java7已经开始转移永久代内部分内容到堆中，但是还是保留了永久代
  * 元空间采用的是本地内存存储而非虚拟机内存

#### 垃圾回收机制

* java的垃圾回收机制工作流程（根节点搜索算法）
* GMS 和G1的区别

#### 类加载流程

在java中类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤需要通过加载、连接、初始化、使用、卸载5个主要流程。

* 装载：查找和导入Class文件（既可以是本地文件也可以是）；

* 链接：把类的二进制数据合并到JRE中；

  * 校验：检查载入Class文件数据的正确性；

  * 准备：给类的静态变量分配存储空间;

  * 解析：将符号引用转成直接引用;
* 初始化：对类的静态变量，静态代码块执行初始化操作

![img](https://raw.githubusercontent.com/HermiteZhang/typoraImage/main/typora/202104/19/182552-129948.webp)

#### 类加载器

> 对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。

* ==一个类能被加载多次么？==：基于类加载器的原理，一个类可以存在被加载多次的情况，此情况一般出现在被同级的类加载重复加载的情况
* ==java/javax包下的类会被加载多次么？==：不会，基于双亲委派原则以java开头的类会被bootstarp加载器进行加载。
* ==如果一个类被加载多次会发生什么？==：会导致本应该可以赋值的两个类会出现报错的问题。

#### 双亲委派模型

> 双亲委派是指当一个类需要加载一个类时，首先进行的是委托上级进行加载，当上级不能加载这个类时，比如某类不在上级的搜索范围中，才会向下进行委托加载。

==如何打破双亲委派==，双亲委派机制只是一种规范，在java中通过类加载器+类全称来确定一个类的唯一性，因此在创建自定义类加载器时，覆写loadClass即可，或者使用SPI 模式加载

![img](https://raw.githubusercontent.com/HermiteZhang/typoraImage/main/typora/202104/21/164803-827467.png)

#### 对象实例化

* new 指令，首先会去判断类对象是否被加载，若为被加载，执行类加载过程
* 对象结构，
  * ==一个空对象（new Object() ）占用16个字节==，分别是8个是对象头，8个是类对象指针
  * 当开启指针压缩时，对象指针只占用4个字节，此时会补4个对齐位，因此对象还是占用16个字节
  * 如何观察对象
    * jvisualvm：jdk自带，jdk的bin目录下有jvisualvm.exe。执行即可
    * jol：OpenJDK提供的jol（Java Object Layout）库进行观察。调用类库
* 通过直接拿到对应类对象来构建代理对象可实现动态代理。



![在这里插入图片描述](https://raw.githubusercontent.com/HermiteZhang/typoraImage/main/typora/202104/19/192049-188971.png)

### java代理

>代理模式是一种设计模式，是通过设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。

#### 静态代理

静态代理通过内置被代理对象，并实现被代理类的所有接口——其接口内部的代理实质上是调用被代理对象的接口执行的

* 优点：可以在不修改目标对象的前提下扩展目标对象的功能。
* 缺点：冗余、不易维护

#### 动态代理

使用JDk提供的Proxy类实现，具体流程如下：代理工程内置被代理的目标对象，并提供Proxy对象的初始化方法。使用时，初始化代理对象是需要制定类加载器、实现的接口，覆盖invoke方法（通过实现接口InvocationHandler），代理对象拿到代理类的基本信息，动态生成字节码，加载到VM中，然后利用==反射接口代理机制==，在执行被代理对象的接口方法时，先执行代理对象覆写的invoke，然后再执行被代理对象的invoke。

	*  静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件
	*  动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中

#### cglib代理

cglib (Code Generation Library )是一个第三方代码生成类库，其他原理与proxy提供的动态代理类型，==只是没有采用接口方式，而是运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展==。

- JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。
  如果想代理没有实现接口的类，就可以使用CGLIB实现。
- CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。
  它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。
- CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。
  不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。
- ==使用动态代理的对象必须实现一个或多个接口==
- ==使用cglib代理的对象则无需实现接口，达到代理类无侵入==。

### 集合

#### Collection 

* collection的常见集合，如下图所示常见的有：ArrayList（有序-数组形式）、ArrayDeque(双端队列)、LinkedList（有序-链表）、Vector(有序线程安全)、HashSet(无序不重复)、TreeSet(有序不重复) 
![image-20210413225745197](https://raw.githubusercontent.com/HermiteZhang/typoraImage/main/typora/202104/13/225749-123122.png)
* ArrayList的实现原理：
  * 底层使用数组实现，初始化时会设置一个默认为10的数组
  * 当超长时会进行==扩容==，扩容系数为1.5：new = old +( old>>1) ,并将旧数组完全拷贝到新数组中
  * ==移动元素==，删除元素时会将后面的数组内容前移，非尾插时也会移动数组内容
*  LinkedList的实现原理
  * 底层使用的==双向链表==实现，私有变量记录一个头部节点和尾部节点
  * 通过下标访问时，采取遍历的形式找到节点（会通过判断下标处于大致区间来判断使用头部遍历还是尾部遍历）
  * 实现deque接口，提供队列能力
* ArrayList和LinkedList的对比
  * 从结构理论上来说==AL比LL访问要快，删插要慢，占用内存小==；
  * 从实现的角度上说：
    * 随机插入，LL需要先遍历到对应元素才能进行插入，AL需要移动元素
    * 头插和尾插，LL可以直接进行插入，AL的头插需要移动所有元素，尾插也是可以直接插入
    * 插入时，AL可能需要扩容(可进行指定容量)，LL则需要构建对象。
    * 删除时，AL要移动元素，LL可以直接删除，操作指针即可
* Vector的实现原理
  * 底层使用数组实现
  * 线程安全采用synchronized修饰相关读写方法
* HashSet的实现原理
  * HashSet底层使用HashMap实现，Set集合中所有的值存储为HashMap的Key（**值的唯一性**），Value默认为一个空的Object对象
  * 遍历迭代器采用的是map的KeySet
* TreeSet的实现原理
  * HashTree是集合类中提供的一个==唯一且有序的集合==
  * 底层采用TreeMap实现，同样的将值存储在TreeMap的key 中来保证唯一性，通过树的特性来保证自然顺序（非指定顺序，默认升序），可以通过Comparator接口自定义排序

#### Map

* HashMap

  * HashMap 的底层原理
    * 
  * HashMap 的扩容机制
  * HashMap 在1.8做了什么改进
  * HashMap 是线程安全的么
* TreeMap
	* 
* ConcurrentHashMap
	* 为什么ConcurrentHashMap是线程安全的

### 多线程及并发
#### 幂等性

#### 线程池

* 线程池的参数
* 线程池的运行流程

#### sycronized 

* sycronized 的实现原理（锁升级的实现流程）

  ![img](https://raw.githubusercontent.com/HermiteZhang/typoraImage/main/typora/202104/22/175855-334662.png)

* sycronized中涉及到的各种锁

  

| 锁状态             | 优点                                                 | 缺点                                   | 使用场景                                   |
| ------------------ | ---------------------------------------------------- | -------------------------------------- | ------------------------------------------ |
| 偏向锁             | 加解锁无需额外消耗，和非同步方法相差纳秒级别（存疑） | 当竞争线程过多，会带来额外的锁撤销消耗 | 没有竞争锁的同步场景                       |
| 轻量级锁（自旋锁） | 竞争不会阻塞，自旋提高程序响应速度                   | 长时间自旋会造成CPU的消耗              | 适用于少量竞争、持锁时间不长、追响应速度。 |
| 重量级锁(线程阻塞) | 不会导致cpu空转                                      | 线程阻塞、响应时间长                   | 多竞争、持锁时间长，最求吞吐量             |

* sycronized、Lock、volatile 的区别

  |      | sycronized | Lock | volatile |
  | ---- | ---------- | ---- | -------- |
  |      |            |      |          |
  |      |            |      |          |
  |      |            |      |          |

  

* volatile ++问题


### JavaSE



## OO及设计模式



## 缓存

### Redis
* redis 如何实现分布式锁，如何使用
* redis 的集群模式
* redis 如何对集群扩容
* redis 如何保证高可用
* redis 如何保证原子性


## 数据库（Mysql）
#### 数据库事务的隔离级别
#### mysql 的事务隔离级别，实现原理
#### mysql 的索引结构
* 聚簇索引和非聚簇索引的区别 
* B和B+树的区别 
* 组合索引的工作原理 
* 慢查询的解决办法


## Spring
### Spring Framework 
#### IOC 
* 实现原理
#### AOP 
* 实现原理

#### 事务

* 实现原理

### SpringMVC 
* spring MVC的工作流程

### Spring Boot

* 简述
* spring boot的优势

### Spring Cloud（微服务）

* Spring cloud 9大组件
* 服务间通信流程
* 路由生成和路由转发流程
* 心跳检测的流程



## ORM

### hibernate

#### hibernate 的缓存机制

#### hibernate 事务

* 事务并发
  * 基于version的乐观锁
   * 基于timestamp的乐观锁

### mybaits



## 消息队列



### Kafka的性能优化



## liunx



## 问题定位



## 场景



#### 参考书目

* [廖雪峰的Java教程 ](https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984)

*  [领域驱动设计在互联网业务开发中的实践](https://tech.meituan.com/2017/12/22/ddd-in-practice.html)

